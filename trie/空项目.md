é¡¹ç›®è¯´æ˜  åœ¨æœ€åä¸€æ¬¡ä½œä¸šä¸­ï¼Œæ‚¨éœ€è¦è¿ç”¨æœ¬å­¦æœŸçš„çŸ¥è¯†æ¥å®ç°ä¸€ä¸ªç»¼åˆæ€§çš„C++é¡¹ç›®â€”Copy-On-Write  Trieã€‚ è¯¥ä½œä¸šæ”¹ç¼–è‡ªCMU 15-445 2023Fall Project0ï¼Œåœ¨å¡å†…åŸºæ¢…éš†å¤§å­¦ï¼Œå­¦ç”Ÿå¿…é¡»ä»¥æ»¡åˆ†å®Œæˆè¯¥é¡¹ç›®ï¼Œç„¶ åæ‰èƒ½ç»§ç»­å­¦ä¹ æ•°æ®åº“ç³»ç»ŸåŸºç¡€è¯¾ç¨‹ã€‚å¦‚æœæ‚¨å¯¹åŠ©æ•™ç¿»è¯‘çš„æ–‡æ¡£ä¸æ»¡æ„ï¼Œæˆ‘ä»¬æ¨èæ‚¨å¯ä»¥åœ¨ä¸‹é¢çš„é“¾æ¥ ä¸­é˜…è¯»è‹±æ–‡åŸç‰ˆçš„Task1å’ŒTask2éƒ¨åˆ†ã€‚ é¡¹ç›® #0 - C++ å…¥é—¨ |CMU 15-445/645 ï¼šï¼š æ•°æ®åº“ç³»ç»Ÿç®€ä»‹ï¼ˆ2023 å¹´ç§‹å­£ï¼‰ ä¸ºäº†ç¡®ä¿æ‚¨äº†è§£ä¸€äº›æœ€åŸºç¡€çš„C++å¹¶å‘ç¼–ç¨‹çŸ¥è¯†ï¼Œæˆ‘ä»¬å»ºè®®æ‚¨åœ¨è¿›å…¥Task2å‰å®Œæˆç¬¬å››æ¬¡å®¶åº­ä½œä¸šä¸­çš„ ã€Šå¹¶å‘æ§åˆ¶ã€‹ã€‚ ä½œä¸šçš„æ¡†æ¶ä»£ç å·²ç»å…¬å¸ƒåœ¨è¯¾ç¨‹QQç¾¤ä¸­ã€‚å¯¹äºæœ¬é¢˜ï¼Œæ‚¨å¯ä»¥åœ¨è‡ªå·±çš„IDEä¸­ç¼–å†™ä»£ç ï¼Œè¯·ç¡®ä¿æ‚¨åœ¨æœ¬åœ° é…ç½®å¥½C++17çš„å¼€å‘ç¯å¢ƒã€‚ é¡¹ç›®æè¿°  åœ¨æœ¬é¡¹ç›®ä¸­ï¼Œæ‚¨å°†å®ç°ä¸€ä¸ªåŸºäºå†™æ—¶å¤åˆ¶å­—å…¸æ ‘ï¼ˆcopy-on-write trieï¼‰çš„é”®å€¼ï¼ˆkey-valueï¼‰å­˜å‚¨å®¹ å™¨ã€‚Tries æ˜¯é«˜æ•ˆçš„æœ‰åºæ ‘å‹æ•°æ®ç»“æ„ï¼Œç”¨äºæ£€ç´¢ç»™å®šé”®çš„å€¼ã€‚ä¸ºäº†ç®€åŒ–è§£é‡Šï¼Œæˆ‘ä»¬å°†å‡è®¾é”®æ˜¯å¯å˜é•¿ åº¦çš„å­—ç¬¦ä¸²ï¼Œä½†å®é™…ä¸Šå®ƒä»¬å¯ä»¥æ˜¯ä»»æ„ç±»å‹ã€‚ trie ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½å¯ä»¥æœ‰å¤šä¸ªå­èŠ‚ç‚¹ï¼Œè¡¨ç¤ºä¸åŒçš„å¯èƒ½çš„ next å­—ç¬¦ã€‚ æ‚¨å°†å®ç°çš„é”®å€¼å­˜å‚¨å¯ä»¥å­˜å‚¨æ˜ å°„åˆ°ä»»ä½•ç±»å‹å€¼çš„å­—ç¬¦ä¸²é”®ã€‚é”®çš„å€¼å­˜å‚¨åœ¨è¡¨ç¤ºè¯¥é”®çš„æœ€åä¸€ä¸ªå­—ç¬¦çš„ èŠ‚ç‚¹ï¼ˆåˆåç»ˆç«¯èŠ‚ç‚¹ï¼‰ä¸­ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘å°† kv å¯¹ ("ab", 1) å’Œ  ("ac", "val") æ’å…¥åˆ° trie ä¸­ã€‚ Task 1ï¼šå®ç°Copy-On-Write Trie (71%)  åœ¨Task1ä¸­ï¼Œæ‚¨éœ€è¦ä¿®æ”¹ trie.h å’Œ trie.cpp æ¥å®ç° copy-on-write trieã€‚åœ¨å†™æ—¶å¤åˆ¶çš„trieä¸­ï¼Œæ“ä½œä¸ ä¼šç›´æ¥ä¿®æ”¹åŸå§‹trieçš„èŠ‚ç‚¹ï¼Œè€Œæ˜¯ä¼šä¸ºä¿®æ”¹åçš„æ•°æ®åˆ›å»ºæ–°çš„èŠ‚ç‚¹ï¼Œå¹¶ä¸ºæ–°ä¿®æ”¹çš„trieè¿”å›æ–°çš„æ ¹èŠ‚ç‚¹ã€‚ Copy-on-write ä½¿æˆ‘ä»¬èƒ½å¤Ÿåœ¨æ¯æ¬¡æ“ä½œåéšæ—¶ä»¥æœ€å°çš„å¼€é”€è®¿é—® trieã€‚è€ƒè™‘åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­æ’å…¥ ("ad", 2) ï¼Œæˆ‘ä»¬é€šè¿‡é‡ç”¨åŸå§‹æ ‘ä¸­çš„ä¸¤ä¸ªå­èŠ‚ç‚¹å¹¶åˆ›å»ºä¸€ä¸ªæ–°çš„ node 2 æ¥åˆ›å»ºæ–°çš„èŠ‚ç‚¹ Node2 ã€‚ ï¼ˆè§ä¸‹å›¾ï¼‰ å¦‚æœæˆ‘ä»¬éšåæ’å…¥ ("b", 3) ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªæ–°çš„æ ¹ã€ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹å¹¶é‡ç”¨ä»¥å‰çš„èŠ‚ç‚¹ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬ å¯ä»¥åœ¨æ¯æ¬¡æ’å…¥æ“ä½œä¹‹å‰å’Œä¹‹åè·å– trie çš„å†…å®¹ã€‚åªè¦æˆ‘ä»¬æœ‰æ ¹å¯¹è±¡ ï¼ˆ  Trie ç±»ï¼‰ï¼Œæˆ‘ä»¬å°±å¯ä»¥åœ¨é‚£ ä¸ªæ—¶å€™è®¿é—® trie é‡Œé¢çš„æ•°æ®ã€‚ï¼ˆè§ä¸‹å›¾ï¼‰ å†ä¸¾ä¸€ä¸ªä¾‹å­ï¼šå¦‚æœæˆ‘ä»¬æ’å…¥ ("a", "abc") å¹¶åˆ é™¤ ("ab", 1) ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸‹é¢çš„trieã€‚è¯·æ³¨æ„ï¼Œçˆ¶ èŠ‚ç‚¹å¯ä»¥å…·æœ‰å€¼ï¼Œåˆ é™¤åéœ€è¦æ¸…é™¤æ‰€æœ‰ä¸å¿…è¦çš„èŠ‚ç‚¹ã€‚ç©º trie ç”¨  nullptr è¡¨ç¤ºã€‚ æ‚¨çš„ trie å¿…é¡»æ”¯æŒä¸‰ä¸ªæ“ä½œï¼š Get(key) ï¼šè·å– key å¯¹åº”çš„å€¼ã€‚ Put(key, value) ï¼šä¸º key è®¾ç½®ç›¸åº”çš„å€¼ã€‚å¦‚æœé”®å·²å­˜åœ¨ï¼Œåˆ™è¦†ç›–ç°æœ‰å€¼ã€‚è¯·æ³¨æ„ï¼Œå€¼çš„ç±»å‹å¯èƒ½ æ˜¯ä¸å¯å¤åˆ¶çš„ï¼ˆå³  std::unique_ptr ï¼‰ã€‚æ­¤æ–¹æ³•è¿”å›ä¸€ä¸ªæ–°çš„ trieã€‚ Delete(key) ï¼šåˆ é™¤é”®çš„å€¼ã€‚æ­¤æ–¹æ³•è¿”å›ä¸€ä¸ªæ–°çš„ trieã€‚ è¿™äº›æ“ä½œéƒ½ä¸åº”ç›´æ¥åœ¨ trie æœ¬èº«ä¸Šæ‰§è¡Œã€‚æ‚¨åº”è¯¥åˆ›å»ºæ–°çš„ trie èŠ‚ç‚¹å¹¶å°½å¯èƒ½é‡ç”¨ç°æœ‰çš„ trie èŠ‚ç‚¹ã€‚ è¦åˆ›å»ºä¸€ä¸ªå…¨æ–°çš„èŠ‚ç‚¹ï¼ˆå³ä¸€ä¸ªæ²¡æœ‰å­èŠ‚ç‚¹çš„æ–°å¶èŠ‚ç‚¹ï¼‰ï¼Œä½ å¯ä»¥ç®€å•åœ°ä½¿ç”¨ TrieNodeWithValue æ„é€  å‡½æ•°æ„é€ å¯¹è±¡ï¼Œç„¶åå°†å…¶å˜æˆä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆã€‚è¦ copy-on-write åˆ›å»ºæ–°èŠ‚ç‚¹ï¼Œæ‚¨åº”è¯¥ä½¿ç”¨  TrieNode  ä¸Šçš„  Clone æ–¹æ³•ã€‚è¦åœ¨æ–° trie ä¸­é‡ç”¨ç°æœ‰èŠ‚ç‚¹ï¼Œæ‚¨å¯ä»¥å¤åˆ¶ std::shared_ptr ï¼šå¤åˆ¶å…±äº«æŒ‡ é’ˆä¸ä¼šå¤åˆ¶åº•å±‚æ•°æ®ã€‚æ‚¨ä¸åº”è¯¥åœ¨æ­¤é¡¹ç›®ä¸­ä½¿ç”¨ new å’Œ delete æ‰‹åŠ¨åˆ†é…å†…å­˜ã€‚  æ²¡æœ‰äººå¼•ç”¨åº•å±‚å¯¹è±¡æ—¶é‡Šæ”¾è¯¥å¯¹è±¡ã€‚ std::shared_ptr å°†åœ¨ Noteï¼šåœ¨ä¸‹å­¦æœŸçš„ã€Šè½¯ä»¶ç³»ç»Ÿè®¾è®¡ã€‹è¯¾ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä¼šå­¦ä¹ ç›¸å…³çš„è®¾è®¡æ¨¡å¼ã€‚æ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥æ å‰äº†è§£"åŸå‹æ¨¡å¼"ã€‚ æœ‰å…³è¿™äº›æ“ä½œçš„å®Œæ•´è§„èŒƒï¼Œè¯·å‚é˜…èµ·å§‹ä»£ç ä¸­çš„æ³¨é‡Šã€‚æ‚¨çš„å®ç°åº”æŒ‰ç…§ä¸Šé¢çš„ä¾‹å­å­˜å‚¨æ•°æ®ã€‚ä¸è¦å°†  C å­—ç¬¦ä¸²ç»ˆæ­¢ç¬¦\0å­˜å‚¨åœ¨ trie ä¸­ã€‚ç¦æ­¢ä»ç±»å®šä¹‰ä¸­åˆ é™¤ä»»ä½•  const æˆ–ä½¿ç”¨  mutable /  æ¥ç»•è¿‡ const æ£€æŸ¥ã€‚ æ­£ç¡®å®Œæˆä¸Šé¢çš„ä»£ç ï¼Œä½ å¯ä»¥å¾—åˆ°71%çš„åˆ†æ•°ã€‚ Task 2ï¼šå¹¶å‘Key-Valueå­˜å‚¨ (29%)  const_cast  åœ¨æ‹¥æœ‰å¯åœ¨å•çº¿ç¨‹ç¯å¢ƒä¸­ä½¿ç”¨çš„å†™å…¥æ—¶å¤åˆ¶ trie åï¼Œä¸ºå¤šçº¿ç¨‹ç¯å¢ƒå®ç°å¹¶å‘é”®å€¼å­˜å‚¨ã€‚åœ¨æ­¤ä»»åŠ¡ä¸­ï¼Œæ‚¨ éœ€è¦ä¿®æ”¹ trie_store.h å’Œ  trie_store.cpp ã€‚æ­¤é”®å€¼å­˜å‚¨è¿˜æ”¯æŒ 3 ç§æ“ä½œï¼š Get(key) ï¼šè¿”å›å¯¹åº” key çš„å€¼ã€‚ Put(key, value) ï¼šæ— è¿”å›å€¼ã€‚ Delete(key) ï¼šæ— è¿”å›å€¼ã€‚ å¯¹äºåŸå§‹çš„ Trie ç±»ï¼Œæ¯æ¬¡ä¿®æ”¹ trie æ—¶ï¼Œéƒ½éœ€è¦è·å–æ–°çš„æ ¹æ¥è®¿é—®æ–°çš„å†…å®¹ã€‚ä½†å¯¹äºå¹¶å‘é”®å€¼å­˜å‚¨ï¼Œ put å’Œ  delete æ–¹æ³•æ²¡æœ‰è¿”å›å€¼ã€‚è¿™è¦æ±‚æ‚¨ä½¿ç”¨å¹¶å‘æ§åˆ¶æ¥åŒæ­¥è¯»å–å’Œå†™å…¥ï¼Œä»¥ä¾¿åœ¨æ­¤è¿‡ç¨‹ä¸­ä¸ä¼šä¸¢å¤± ä»»ä½•æ•°æ®ã€‚ æ‚¨çš„å¹¶å‘é”®å€¼å­˜å‚¨åº”åŒæ—¶ä¸ºå¤šä¸ªè¯»è€…å’Œå•ä¸ªå†™è€…æä¾›æœåŠ¡ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“æœ‰äººä¿®æ”¹ trie æ—¶ï¼Œä»ç„¶å¯ä»¥ åœ¨æ—§æ ¹ä¸Šæ‰§è¡Œè¯»å–æ“ä½œã€‚å½“æœ‰äººæ­£åœ¨è¯»å–æ—¶ï¼Œä»ç„¶å¯ä»¥æ‰§è¡Œå†™å…¥ï¼Œè€Œæ— éœ€ç­‰å¾…è¯»å–ã€‚ æ­¤å¤–ï¼Œå¦‚æœæˆ‘ä»¬ä» trie è·å¾—å¯¹å€¼çš„å¼•ç”¨ï¼Œé‚£ä¹ˆæ— è®ºæˆ‘ä»¬å¦‚ä½•ä¿®æ”¹ trieï¼Œæˆ‘ä»¬éƒ½åº”è¯¥èƒ½å¤Ÿè®¿é—®å®ƒã€‚ Trie çš„Getå‡½æ•°ä»…è¿”å›ä¸€ä¸ªæŒ‡é’ˆã€‚å¦‚æœå­˜å‚¨æ­¤å€¼çš„ trie èŠ‚ç‚¹å·²è¢«åˆ é™¤ï¼Œåˆ™æŒ‡é’ˆå°†æ‚¬ç©ºã€‚å› æ­¤ï¼Œåœ¨ TrieStore  ä¸­ï¼Œæˆ‘ä»¬è¿”å›ä¸€ä¸ª ValueGuard ï¼Œå®ƒåŒæ—¶å­˜å‚¨å¯¹å€¼çš„å¼•ç”¨å’Œå¯¹åº”äº trie ç»“æ„æ ¹çš„ TrieNodeï¼Œä»¥ä¾¿å¯ä»¥ è®¿é—®å€¼åœ¨æˆ‘ä»¬å­˜å‚¨  ValueGuard çš„æ—¶å€™ã€‚ ä¸ºæ­¤ï¼Œæˆ‘ä»¬åœ¨ trie_store.cpp ä¸ºæ‚¨æä¾›äº† TrieStore::Get çš„ä¼ªä»£ç ã€‚è¯·ä»”ç»†é˜…è¯»å¹¶è€ƒè™‘å¦‚ä½•å®ç° TrieStore::Put å’Œ  TrieStore::Remove ã€‚ æ­£ç¡®å®Œæˆä¸Šé¢çš„ä»£ç ï¼Œä½ å¯ä»¥å¾—åˆ°æ‰€æœ‰çš„åˆ†æ•°ğŸ‰ã€‚ ç¯å¢ƒé…ç½®  æˆ‘ä»¬æ¨èæ‚¨åœ¨Linuxç¯å¢ƒä¸‹å®Œæˆè¿™é“ç»ƒä¹ ã€‚æ‚¨éœ€è¦é…ç½®å¥½C++17çš„ç¯å¢ƒï¼Œå¹¶å®‰è£…å¿…è¦çš„åº“ï¼š sudo apt install libfmt-dev  # Ubuntu/Debian sudo dnf install fmt-devel  # Fedora å¦‚æœæ‚¨é€‰æ‹©å®Œæˆé…ç½®åŸç‰ˆå®éªŒçš„ç¯å¢ƒå¹¶å…‹éš†äº†åŸç‰ˆå®éªŒï¼Œè¯·æ³¨æ„åŸç‰ˆæ¡†æ¶å’ŒCPPä½œä¸šæ¡†æ¶çš„å·®åˆ«ã€‚ æµ‹è¯•  ç”±äºCPPOJä¸æ”¯æŒä½¿ç”¨GTestè¿›è¡Œå•å…ƒæµ‹è¯•ï¼Œæˆ‘ä»¬ç¼–å†™äº† SimpleGTest.h æ¥æµ‹è¯•å¤§å®¶çš„ä»£ç ã€‚æ‚¨å¯ä»¥åœ¨ æ ‡å‡†è¾“å…¥ä¸­è¾“å…¥å¯¹åº”çš„å‡½æ•°åæ¥è¿›è¡Œè‡ªæµ‹ï¼Œä¾‹å¦‚ï¼šTrieTest_ConstructorTestã€‚ åŒåŸç‰ˆå®éªŒä¸€æ ·ï¼Œåœ¨è¿™ä¸ªé¡¹ç›®ä¸­æ²¡æœ‰éšè—çš„æµ‹è¯•ç”¨ä¾‹ã€‚ä½†ä¸åŸç‰ˆé¡¹ç›®ä¸åŒçš„æ˜¯ï¼Œæ‰€æœ‰æµ‹è¯•ç”¨ä¾‹å‡ç¼–å†™åœ¨ Main.cpp æ–‡ä»¶ä¸­ã€‚ æ ¼å¼åŒ–ä¸å†…å­˜æ³„æ¼  ç”±äºCPPOJçš„è¯„æµ‹é™åˆ¶ï¼Œæˆ‘ä»¬ä¸ä¼šçš„å¤§å®¶çš„æ ¼å¼åŒ–å’Œå†…å­˜æ³„æ¼è¿›è¡Œæµ‹è¯•ã€‚ä½†æ˜¯ä½ å†™çš„ç¨‹åºåº”è¯¥å°½å¯èƒ½æ»¡ è¶³ä¸‹åˆ—è¦æ±‚ï¼š æ‚¨çš„ä»£ç åº”å½“éµå¾ª Google C++ æ ·å¼æŒ‡å—ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ Clang è‡ªåŠ¨æ£€æŸ¥æ‚¨çš„æºä»£ç çš„è´¨é‡ã€‚ æ‚¨çš„ä»£ç ä¸åº”è¯¥å­˜åœ¨å†…å­˜æ³„æ¼ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ LLVM åœ°å€æ¸…ç†å™¨ ï¼ˆASANï¼‰ å’Œæ³„æ¼æ¸…ç†å™¨  ï¼ˆLSANï¼‰ æ¥æ£€æŸ¥å†…å­˜é”™è¯¯ã€‚ æäº¤  ä½ éœ€è¦åœ¨CPPOJæäº¤çš„ä»£ç æ–‡ä»¶æœ‰ï¼š OJåœ¨æµ‹è¯•æ—¶ä¼šè‡ªåŠ¨å¡«å……ã€‚ å…¶ä»–è¦æ±‚  trie.h ,  trie.cpp ,  trie_store.h å’Œ trie_store.cpp ã€‚å…¶ä½™æ–‡ä»¶

//main.cpp

#include "SimpleGTest.h"

\#include "trie.h"

\#include "trie_store.h"

\#include <cassert>

\#include <cstdlib>

\#include <functional>

\#include <optional>



using Integer = std::unique_ptr<uint32_t>;



// === TRIE_TEST_CASES (71%) ===

void TrieTest_ConstructorTest();

void TrieTest_BasicPutTest();

void TrieTest_TrieStructureCheck();

void TrieTest_BasicPutGetTest();

void TrieTest_PutGetOnePath();

void TrieTest_BasicRemoveTest1();

void TrieTest_BasicRemoveTest2();

void TrieTest_RemoveFreeTest();

void TrieTest_MismatchTypeTest();

void TrieTest_CopyOnWriteTest1();

void TrieTest_CopyOnWriteTest2();

void TrieTest_CopyOnWriteTest3();

void TrieTest_MixedTest();

void TrieTest_PointerStability();

void TrieTest_NonCopyableTest();



// === TRIE_STROE_TEST_CASES (29%) ===

void TrieStoreTest_BasicTest();

void TrieStoreTest_GuardTest();

void TrieStoreTest_MixedTest();

void TrieStoreTest_MixedConcurrentTest();

void TrieStoreTest_NonCopyableTest();

void TrieStoreTest_ReadWriteTest();



\#define REGISTER_TEST_CASE(name) {#name, name}



int main() {

 std::unordered_map<std::string, std::function<void()>>

   test_functions_by_name = {

â€‹     REGISTER_TEST_CASE(TrieTest_ConstructorTest),

â€‹     REGISTER_TEST_CASE(TrieTest_BasicPutTest),

â€‹     REGISTER_TEST_CASE(TrieTest_TrieStructureCheck),

â€‹     REGISTER_TEST_CASE(TrieTest_BasicPutGetTest),

â€‹     REGISTER_TEST_CASE(TrieTest_PutGetOnePath),

â€‹     REGISTER_TEST_CASE(TrieTest_BasicRemoveTest1),

â€‹     REGISTER_TEST_CASE(TrieTest_BasicRemoveTest2),

â€‹     REGISTER_TEST_CASE(TrieTest_RemoveFreeTest),

â€‹     REGISTER_TEST_CASE(TrieTest_MismatchTypeTest),

â€‹     REGISTER_TEST_CASE(TrieTest_CopyOnWriteTest1),

â€‹     REGISTER_TEST_CASE(TrieTest_CopyOnWriteTest2),

â€‹     REGISTER_TEST_CASE(TrieTest_CopyOnWriteTest3),

â€‹     REGISTER_TEST_CASE(TrieTest_MixedTest),

â€‹     REGISTER_TEST_CASE(TrieTest_PointerStability),

â€‹     REGISTER_TEST_CASE(TrieTest_NonCopyableTest),

â€‹     REGISTER_TEST_CASE(TrieStoreTest_BasicTest),

â€‹     REGISTER_TEST_CASE(TrieStoreTest_GuardTest),

â€‹     REGISTER_TEST_CASE(TrieStoreTest_MixedTest),

â€‹     REGISTER_TEST_CASE(TrieStoreTest_MixedConcurrentTest),

â€‹     REGISTER_TEST_CASE(TrieStoreTest_NonCopyableTest),

â€‹     REGISTER_TEST_CASE(TrieStoreTest_ReadWriteTest),

   };



 std::string test_case_name;

 std::cin >> test_case_name;

 auto it = test_functions_by_name.find(test_case_name);

 assert(it != test_functions_by_name.end());

 auto fn = it->second;

 fn();

 return 0;

}



TEST(TrieTest, ConstructorTest) { auto trie = Trie(); }



TEST(TrieTest, BasicPutTest) {

 auto trie = Trie();

 trie = trie.Put<uint32_t>("test-int", 233);

 trie = trie.Put<uint64_t>("test-int2", 23333333);

 trie = trie.Put<std::string>("test-string", "test");

 trie = trie.Put<std::string>("", "empty-key");

}



TEST(TrieTest, TrieStructureCheck) {

 auto trie = Trie();

 // Put something

 trie = trie.Put<uint32_t>("test", 233);

 ASSERT_EQ(*trie.Get<uint32_t>("test"), 233);

 // Ensure the trie is the same representation of the writeup

 // (Some students were using '\0' as the terminator in previous semesters)

 auto root = trie.GetRoot();

 ASSERT_EQ(root->children_.size(), 1);

 ASSERT_EQ(root->children_.at('t')->children_.size(), 1);

 ASSERT_EQ(root->children_.at('t')->children_.at('e')->children_.size(), 1);

 ASSERT_EQ(root->children_.at('t')->children_.at('e')->children_.at('s')->children_.size(), 1);

 ASSERT_EQ(root->children_.at('t')->children_.at('e')->children_.at('s')->children_.at('t')->children_.size(), 0);

 ASSERT_TRUE(root->children_.at('t')->children_.at('e')->children_.at('s')->children_.at('t')->is_value_node_);

}



TEST(TrieTest, BasicPutGetTest) {

 auto trie = Trie();

 // Put something

 trie = trie.Put<uint32_t>("test", 233);

 ASSERT_EQ(*trie.Get<uint32_t>("test"), 233);

 // Put something else

 trie = trie.Put<uint32_t>("test", 23333333);

 ASSERT_EQ(*trie.Get<uint32_t>("test"), 23333333);

 // Overwrite with another type

 trie = trie.Put<std::string>("test", "23333333");

 ASSERT_EQ(*trie.Get<std::string>("test"), "23333333");

 // Get something that doesn't exist

 ASSERT_EQ(trie.Get<std::string>("test-2333"), nullptr);

 // Put something at root

 trie = trie.Put<std::string>("", "empty-key");

 ASSERT_EQ(*trie.Get<std::string>(""), "empty-key");

}



TEST(TrieTest, PutGetOnePath) {

 auto trie = Trie();

 trie = trie.Put<uint32_t>("111", 111);

 trie = trie.Put<uint32_t>("11", 11);

 trie = trie.Put<uint32_t>("1111", 1111);

 trie = trie.Put<uint32_t>("11", 22);

 ASSERT_EQ(*trie.Get<uint32_t>("11"), 22);

 ASSERT_EQ(*trie.Get<uint32_t>("111"), 111);

 ASSERT_EQ(*trie.Get<uint32_t>("1111"), 1111);

}



TEST(TrieTest, BasicRemoveTest1) {

 auto trie = Trie();

 // Put something

 trie = trie.Put<uint32_t>("test", 2333);

 ASSERT_EQ(*trie.Get<uint32_t>("test"), 2333);

 trie = trie.Put<uint32_t>("te", 23);

 ASSERT_EQ(*trie.Get<uint32_t>("te"), 23);

 trie = trie.Put<uint32_t>("tes", 233);

 ASSERT_EQ(*trie.Get<uint32_t>("tes"), 233);

 // Delete something

 trie = trie.Remove("test");

 trie = trie.Remove("tes");

 trie = trie.Remove("te");



 ASSERT_EQ(trie.Get<uint32_t>("te"), nullptr);

 ASSERT_EQ(trie.Get<uint32_t>("tes"), nullptr);

 ASSERT_EQ(trie.Get<uint32_t>("test"), nullptr);

}



TEST(TrieTest, BasicRemoveTest2) {

 auto trie = Trie();

 // Put something

 trie = trie.Put<uint32_t>("test", 2333);

 ASSERT_EQ(*trie.Get<uint32_t>("test"), 2333);

 trie = trie.Put<uint32_t>("te", 23);

 ASSERT_EQ(*trie.Get<uint32_t>("te"), 23);

 trie = trie.Put<uint32_t>("tes", 233);

 ASSERT_EQ(*trie.Get<uint32_t>("tes"), 233);

 trie = trie.Put<uint32_t>("", 123);

 ASSERT_EQ(*trie.Get<uint32_t>(""), 123);

 // Delete something

 trie = trie.Remove("");

 trie = trie.Remove("te");

 trie = trie.Remove("tes");

 trie = trie.Remove("test");



 ASSERT_EQ(trie.Get<uint32_t>(""), nullptr);

 ASSERT_EQ(trie.Get<uint32_t>("te"), nullptr);

 ASSERT_EQ(trie.Get<uint32_t>("tes"), nullptr);

 ASSERT_EQ(trie.Get<uint32_t>("test"), nullptr);

}



TEST(TrieTest, RemoveFreeTest) {

 auto trie = Trie();

 trie = trie.Put<uint32_t>("test", 2333);

 trie = trie.Put<uint32_t>("te", 23);

 trie = trie.Put<uint32_t>("tes", 233);

 trie = trie.Remove("tes");

 trie = trie.Remove("test");

 ASSERT_EQ(trie.GetRoot()->children_.at('t')->children_.at('e')->children_.size(), 0);

 trie = trie.Remove("te");

 ASSERT_EQ(trie.GetRoot(), nullptr);

}



TEST(TrieTest, MismatchTypeTest) {

 auto trie = Trie();

 // Put something

 trie = trie.Put<uint32_t>("test", 2333);

 ASSERT_EQ(trie.Get<std::string>("test"), nullptr);

}



TEST(TrieTest, CopyOnWriteTest1) {

 auto empty_trie = Trie();

 // Put something

 auto trie1 = empty_trie.Put<uint32_t>("test", 2333);

 auto trie2 = trie1.Put<uint32_t>("te", 23);

 auto trie3 = trie2.Put<uint32_t>("tes", 233);



 // Delete something

 auto trie4 = trie3.Remove("te");

 auto trie5 = trie3.Remove("tes");

 auto trie6 = trie3.Remove("test");



 // Check each snapshot

 ASSERT_EQ(*trie3.Get<uint32_t>("te"), 23);

 ASSERT_EQ(*trie3.Get<uint32_t>("tes"), 233);

 ASSERT_EQ(*trie3.Get<uint32_t>("test"), 2333);



 ASSERT_EQ(trie4.Get<uint32_t>("te"), nullptr);

 ASSERT_EQ(*trie4.Get<uint32_t>("tes"), 233);

 ASSERT_EQ(*trie4.Get<uint32_t>("test"), 2333);



 ASSERT_EQ(*trie5.Get<uint32_t>("te"), 23);

 ASSERT_EQ(trie5.Get<uint32_t>("tes"), nullptr);

 ASSERT_EQ(*trie5.Get<uint32_t>("test"), 2333);



 ASSERT_EQ(*trie6.Get<uint32_t>("te"), 23);

 ASSERT_EQ(*trie6.Get<uint32_t>("tes"), 233);

 ASSERT_EQ(trie6.Get<uint32_t>("test"), nullptr);

}



TEST(TrieTest, CopyOnWriteTest2) {

 auto empty_trie = Trie();

 // Put something

 auto trie1 = empty_trie.Put<uint32_t>("test", 2333);

 auto trie2 = trie1.Put<uint32_t>("te", 23);

 auto trie3 = trie2.Put<uint32_t>("tes", 233);



 // Override something

 auto trie4 = trie3.Put<std::string>("te", "23");

 auto trie5 = trie3.Put<std::string>("tes", "233");

 auto trie6 = trie3.Put<std::string>("test", "2333");



 // Check each snapshot

 ASSERT_EQ(*trie3.Get<uint32_t>("te"), 23);

 ASSERT_EQ(*trie3.Get<uint32_t>("tes"), 233);

 ASSERT_EQ(*trie3.Get<uint32_t>("test"), 2333);



 ASSERT_EQ(*trie4.Get<std::string>("te"), "23");

 ASSERT_EQ(*trie4.Get<uint32_t>("tes"), 233);

 ASSERT_EQ(*trie4.Get<uint32_t>("test"), 2333);



 ASSERT_EQ(*trie5.Get<uint32_t>("te"), 23);

 ASSERT_EQ(*trie5.Get<std::string>("tes"), "233");

 ASSERT_EQ(*trie5.Get<uint32_t>("test"), 2333);



 ASSERT_EQ(*trie6.Get<uint32_t>("te"), 23);

 ASSERT_EQ(*trie6.Get<uint32_t>("tes"), 233);

 ASSERT_EQ(*trie6.Get<std::string>("test"), "2333");

}



TEST(TrieTest, CopyOnWriteTest3) {

 auto empty_trie = Trie();

 // Put something

 auto trie1 = empty_trie.Put<uint32_t>("test", 2333);

 auto trie2 = trie1.Put<uint32_t>("te", 23);

 auto trie3 = trie2.Put<uint32_t>("", 233);



 // Override something

 auto trie4 = trie3.Put<std::string>("te", "23");

 auto trie5 = trie3.Put<std::string>("", "233");

 auto trie6 = trie3.Put<std::string>("test", "2333");



 // Check each snapshot

 ASSERT_EQ(*trie3.Get<uint32_t>("te"), 23);

 ASSERT_EQ(*trie3.Get<uint32_t>(""), 233);

 ASSERT_EQ(*trie3.Get<uint32_t>("test"), 2333);



 ASSERT_EQ(*trie4.Get<std::string>("te"), "23");

 ASSERT_EQ(*trie4.Get<uint32_t>(""), 233);

 ASSERT_EQ(*trie4.Get<uint32_t>("test"), 2333);



 ASSERT_EQ(*trie5.Get<uint32_t>("te"), 23);

 ASSERT_EQ(*trie5.Get<std::string>(""), "233");

 ASSERT_EQ(*trie5.Get<uint32_t>("test"), 2333);



 ASSERT_EQ(*trie6.Get<uint32_t>("te"), 23);

 ASSERT_EQ(*trie6.Get<uint32_t>(""), 233);

 ASSERT_EQ(*trie6.Get<std::string>("test"), "2333");

}



TEST(TrieTest, MixedTest) {

 auto trie = Trie();

 for (uint32_t i = 0; i < 23333; i++) {

  std::string key = fmt::format("{:#05}", i);

  std::string value = fmt::format("value-{:#08}", i);

  trie = trie.Put<std::string>(key, value);

 }

 auto trie_full = trie;

 for (uint32_t i = 0; i < 23333; i += 2) {

  std::string key = fmt::format("{:#05}", i);

  std::string value = fmt::format("new-value-{:#08}", i);

  trie = trie.Put<std::string>(key, value);

 }

 auto trie_override = trie;

 for (uint32_t i = 0; i < 23333; i += 3) {

  std::string key = fmt::format("{:#05}", i);

  trie = trie.Remove(key);

 }

 auto trie_final = trie;



 // verify trie_full

 for (uint32_t i = 0; i < 23333; i++) {

  std::string key = fmt::format("{:#05}", i);

  std::string value = fmt::format("value-{:#08}", i);

  ASSERT_EQ(*trie_full.Get<std::string>(key), value);

 }



 // verify trie_override

 for (uint32_t i = 0; i < 23333; i++) {

  std::string key = fmt::format("{:#05}", i);

  if (i % 2 == 0) {

   std::string value = fmt::format("new-value-{:#08}", i);

   ASSERT_EQ(*trie_override.Get<std::string>(key), value);

  } else {

   std::string value = fmt::format("value-{:#08}", i);

   ASSERT_EQ(*trie_override.Get<std::string>(key), value);

  }

 }



 // verify final trie

 for (uint32_t i = 0; i < 23333; i++) {

  std::string key = fmt::format("{:#05}", i);

  if (i % 3 == 0) {

   ASSERT_EQ(trie_final.Get<std::string>(key), nullptr);

  } else if (i % 2 == 0) {

   std::string value = fmt::format("new-value-{:#08}", i);

   ASSERT_EQ(*trie_final.Get<std::string>(key), value);

  } else {

   std::string value = fmt::format("value-{:#08}", i);

   ASSERT_EQ(*trie_final.Get<std::string>(key), value);

  }

 }

}



TEST(TrieTest, PointerStability) {

 auto trie = Trie();

 trie = trie.Put<uint32_t>("test", 2333);

 auto *ptr_before = trie.Get<std::string>("test");

 trie = trie.Put<uint32_t>("tes", 233);

 trie = trie.Put<uint32_t>("te", 23);

 auto *ptr_after = trie.Get<std::string>("test");

 ASSERT_EQ(reinterpret_cast<uint64_t>(ptr_before), reinterpret_cast<uint64_t>(ptr_after));

}



TEST(TrieTest, NonCopyableTest) {

 auto trie = Trie();

 trie = trie.Put<Integer>("tes", std::make_unique<uint32_t>(233));

 trie = trie.Put<Integer>("te", std::make_unique<uint32_t>(23));

 trie = trie.Put<Integer>("test", std::make_unique<uint32_t>(2333));

 ASSERT_EQ(**trie.Get<Integer>("te"), 23);

 ASSERT_EQ(**trie.Get<Integer>("tes"), 233);

 ASSERT_EQ(**trie.Get<Integer>("test"), 2333);

 trie = trie.Remove("te");

 trie = trie.Remove("tes");

 trie = trie.Remove("test");

 ASSERT_EQ(trie.Get<Integer>("te"), nullptr);

 ASSERT_EQ(trie.Get<Integer>("tes"), nullptr);

 ASSERT_EQ(trie.Get<Integer>("test"), nullptr);

}



TEST(TrieStoreTest, BasicTest) {

 auto store = TrieStore();

 ASSERT_EQ_NO_REPORT(store.Get<uint32_t>("233"), std::nullopt);

 store.Put<uint32_t>("233", 2333);

 {

  auto guard = store.Get<uint32_t>("233");

  ASSERT_EQ(**guard, 2333);

 }

 store.Remove("233");

 {

  auto guard = store.Get<uint32_t>("233");

  ASSERT_EQ_NO_REPORT(guard, std::nullopt);

 }

}



TEST(TrieStoreTest, GuardTest) {

 auto store = TrieStore();

 ASSERT_EQ_NO_REPORT(store.Get<uint32_t>("233"), std::nullopt);



 store.Put<std::string>("233", "2333");

 auto guard = store.Get<std::string>("233");

 ASSERT_EQ(**guard, "2333");



 store.Remove("233");

 {

  auto guard = store.Get<std::string>("233");

  ASSERT_EQ_NO_REPORT(guard, std::nullopt);

 }



 ASSERT_EQ(**guard, "2333");

}



TEST(TrieStoreTest, MixedTest) {

 auto store = TrieStore();

 for (uint32_t i = 0; i < 23333; i++) {

  std::string key = fmt::format("{:#05}", i);

  std::string value = fmt::format("value-{:#08}", i);

  store.Put<std::string>(key, value);

 }

 for (uint32_t i = 0; i < 23333; i += 2) {

  std::string key = fmt::format("{:#05}", i);

  std::string value = fmt::format("new-value-{:#08}", i);

  store.Put<std::string>(key, value);

 }

 for (uint32_t i = 0; i < 23333; i += 3) {

  std::string key = fmt::format("{:#05}", i);

  store.Remove(key);

 }



 // verify final trie

 for (uint32_t i = 0; i < 23333; i++) {

  std::string key = fmt::format("{:#05}", i);

  if (i % 3 == 0) {

   ASSERT_EQ_NO_REPORT(store.Get<std::string>(key), std::nullopt);

  } else if (i % 2 == 0) {

   std::string value = fmt::format("new-value-{:#08}", i);

   auto guard = store.Get<std::string>(key);

   ASSERT_EQ(**guard, value);

  } else {

   std::string value = fmt::format("value-{:#08}", i);

   auto guard = store.Get<std::string>(key);

   ASSERT_EQ(**guard, value);

  }

 }

}



TEST(TrieStoreTest, MixedConcurrentTest) {

 auto store = TrieStore();



 std::vector<std::thread> threads;



 const int keys_per_thread = 500;



 for (int tid = 0; tid < 2; tid++) {

  std::thread t([&store, tid] {

   for (uint32_t i = 0; i < keys_per_thread; i++) {

â€‹    std::string key = fmt::format("{:#05}", i * 2 + tid);

â€‹    std::string value = fmt::format("value-{:#08}", i * 2 + tid);

â€‹    store.Put<std::string>(key, value);

   }

   for (uint32_t i = 0; i < keys_per_thread; i++) {

â€‹    std::string key = fmt::format("{:#05}", i * 2 + tid);

â€‹    store.Remove(key);

   }

   for (uint32_t i = 0; i < keys_per_thread; i++) {

â€‹    std::string key = fmt::format("{:#05}", i * 2 + tid);

â€‹    std::string value = fmt::format("new-value-{:#08}", i * 2 + tid);

â€‹    store.Put<std::string>(key, value);

   }

  });

  threads.push_back(std::move(t));

 }



 std::vector<std::thread> read_threads;

 std::shared_ptr<std::atomic_bool> stop = std::make_shared<std::atomic_bool>(false);



 for (int tid = 0; tid < 2; tid++) {

  std::thread t([&store, tid, stop] {

   uint32_t i = 0;

   while (!stop->load()) {

â€‹    std::string key = fmt::format("{:#05}", i * 2 + tid);

â€‹    store.Get<std::string>(key);

â€‹    i = (i + 1) % keys_per_thread;

   }

  });

  read_threads.push_back(std::move(t));

 }



 for (auto &t : threads) {

  t.join();

 }



 stop->store(true);



 for (auto &t : read_threads) {

  t.join();

 }



 // verify final trie

 for (uint32_t i = 0; i < keys_per_thread * 2; i++) {

  std::string key = fmt::format("{:#05}", i);

  std::string value = fmt::format("new-value-{:#08}", i);

  auto guard = store.Get<std::string>(key);

  ASSERT_EQ(**guard, value);

 }

}



TEST(TrieStoreTest, NonCopyableTest) {

 auto store = TrieStore();

 store.Put<Integer>("tes", std::make_unique<uint32_t>(233));

 store.Put<Integer>("te", std::make_unique<uint32_t>(23));

 store.Put<Integer>("test", std::make_unique<uint32_t>(2333));

 ASSERT_EQ(***store.Get<Integer>("te"), 23);

 ASSERT_EQ(***store.Get<Integer>("tes"), 233);

 ASSERT_EQ(***store.Get<Integer>("test"), 2333);

 store.Remove("te");

 store.Remove("tes");

 store.Remove("test");

 ASSERT_EQ_NO_REPORT(store.Get<Integer>("te"), std::nullopt);

 ASSERT_EQ_NO_REPORT(store.Get<Integer>("tes"), std::nullopt);

 ASSERT_EQ_NO_REPORT(store.Get<Integer>("test"), std::nullopt);

}



TEST(TrieStoreTest, ReadWriteTest) {

 auto store = TrieStore();

 store.Put<uint32_t>("a", 1);

 store.Put<uint32_t>("b", 2);

 store.Put<uint32_t>("c", 3);

 std::promise<int> x;



 std::cerr << "[0] begin" << std::endl;



 std::thread t([&store, &x] { store.Put<MoveBlocked>("d", MoveBlocked(x.get_future())); });



 std::cerr << "[1] thread spawn" << std::endl;



 // Loop for enough time to ensure that the thread is blocked on the promise.

 for (int i = 0; i < 100000; i++) {

  {

   auto guard = store.Get<uint32_t>("a");

   ASSERT_EQ(**guard, 1);

  }

  {

   auto guard = store.Get<uint32_t>("b");

   ASSERT_EQ(**guard, 2);

  }

  {

   auto guard = store.Get<uint32_t>("c");

   ASSERT_EQ(**guard, 3);

  }

 }



 std::cerr << "[2] read done" << std::endl;



 x.set_value(233);



 t.join();



 std::cerr << "[3] write complete" << std::endl;



 ASSERT_NE_NO_REPORT(store.Get<MoveBlocked>("d"), std::nullopt);

}

//trie.h

\#pragma once



\#include <algorithm>

\#include <cstddef>

\#include <future>  // NOLINT

\#include <map>

\#include <memory>

\#include <optional>

\#include <stdexcept>

\#include <string>

\#include <unordered_map>

\#include <utility>

\#include <vector>



/// A special type that will block the move constructor and move assignment operator. Used in TrieStore tests.

class MoveBlocked {

 public:

 explicit MoveBlocked(std::future<int> wait) : wait_(std::move(wait)) {}



 MoveBlocked(const MoveBlocked &) = delete;

 MoveBlocked(MoveBlocked &&that) noexcept {

  if (!that.waited_) {

   that.wait_.get();

  }

  that.waited_ = waited_ = true;

 }



 auto operator=(const MoveBlocked &) -> MoveBlocked & = delete;

 auto operator=(MoveBlocked &&that) noexcept -> MoveBlocked & {

  if (!that.waited_) {

   that.wait_.get();

  }

  that.waited_ = waited_ = true;

  return *this;

 }



 bool waited_{false};

 std::future<int> wait_;

};



// A TrieNode is a node in a Trie.

class TrieNode {

 public:

 // Create a TrieNode with no children.

 TrieNode() = default;



 // Create a TrieNode with some children.

 explicit TrieNode(std::map<char, std::shared_ptr<const TrieNode>> children) : children_(std::move(children)) {}



 virtual ~TrieNode() = default;



 // Clone returns a copy of this TrieNode. If the TrieNode has a value, the value is copied. The return

 // type of this function is a unique_ptr to a TrieNode.

 //

 // You cannot use the copy constructor to clone the node because it doesn't know whether a `TrieNode`

 // contains a value or not.

 //

 // Note: if you want to convert `unique_ptr` into `shared_ptr`, you can use `std::shared_ptr<T>(std::move(ptr))`.

 virtual auto Clone() const -> std::unique_ptr<TrieNode> { return std::make_unique<TrieNode>(children_); }



 // A map of children, where the key is the next character in the key, and the value is the next TrieNode.

 // You MUST store the children information in this structure. You are NOT allowed to remove the `const` from

 // the structure.

 std::map<char, std::shared_ptr<const TrieNode>> children_;



 // Indicates if the node is the terminal node.

 bool is_value_node_{false};



 // You can add additional fields and methods here except storing children. But in general, you don't need to add extra

 // fields to complete this project.

};



// A TrieNodeWithValue is a TrieNode that also has a value of type T associated with it.

template <class T>

class TrieNodeWithValue : public TrieNode {

 public:

 // Create a trie node with no children and a value.

 explicit TrieNodeWithValue(std::shared_ptr<T> value) : value_(std::move(value)) { this->is_value_node_ = true; }



 // Create a trie node with children and a value.

 TrieNodeWithValue(std::map<char, std::shared_ptr<const TrieNode>> children, std::shared_ptr<T> value)

   : TrieNode(std::move(children)), value_(std::move(value)) {

  this->is_value_node_ = true;

 }



 // Override the Clone method to also clone the value.

 //

 // Note: if you want to convert `unique_ptr` into `shared_ptr`, you can use `std::shared_ptr<T>(std::move(ptr))`.

 auto Clone() const -> std::unique_ptr<TrieNode> override {

  return std::make_unique<TrieNodeWithValue<T>>(children_, value_);

 }



 // The value associated with this trie node.

 std::shared_ptr<T> value_;

};



// A Trie is a data structure that maps strings to values of type T. All operations on a Trie should not

// modify the trie itself. It should reuse the existing nodes as much as possible, and create new nodes to

// represent the new trie.

//

// You are NOT allowed to remove any `const` in this project, or use `mutable` to bypass the const checks.

class Trie {

 private:

 // The root of the trie.

 std::shared_ptr<const TrieNode> root_{nullptr};



 // Create a new trie with the given root.

 explicit Trie(std::shared_ptr<const TrieNode> root) : root_(std::move(root)) {}



 public:

 // Create an empty trie.

 Trie() = default;



 // Get the value associated with the given key.

 // 1. If the key is not in the trie, return nullptr.

 // 2. If the key is in the trie but the type is mismatched, return nullptr.

 // 3. Otherwise, return the value.

 template <class T>

 auto Get(std::string_view key) const -> const T *;



 // Put a new key-value pair into the trie. If the key already exists, overwrite the value.

 // Returns the new trie.

 template <class T>

 auto Put(std::string_view key, T value) const -> Trie;



 // Remove the key from the trie. If the key does not exist, return the original trie.

 // Otherwise, returns the new trie.

 auto Remove(std::string_view key) const -> Trie;



 // Get the root of the trie, should only be used in test cases.

 auto GetRoot() const -> std::shared_ptr<const TrieNode> { return root_; }

};

//trie_store.h

\#pragma once



\#include <optional>

\#include <shared_mutex>

\#include <utility>



\#include "trie.h"



// This class is used to guard the value returned by the trie. It holds a reference to the root so

// that the reference to the value will not be invalidated.

template <class T>

class ValueGuard {

 public:

 ValueGuard(Trie root, const T &value) : root_(std::move(root)), value_(value) {}

 auto operator*() const -> const T & { return value_; }



 private:

 Trie root_;

 const T &value_;

};



// This class is a thread-safe wrapper around the Trie class. It provides a simple interface for

// accessing the trie. It should allow concurrent reads and a single write operation at the same

// time.

class TrieStore {

 public:

 // This function returns a ValueGuard object that holds a reference to the value in the trie. If

 // the key does not exist in the trie, it will return std::nullopt.

 template <class T>

 auto Get(std::string_view key) -> std::optional<ValueGuard<T>>;



 // This function will insert the key-value pair into the trie. If the key already exists in the

 // trie, it will overwrite the value.

 template <class T>

 void Put(std::string_view key, T value);



 // This function will remove the key-value pair from the trie.

 void Remove(std::string_view key);



 private:

 // This mutex protects the root. Every time you want to access the trie root or modify it, you

 // will need to take this lock.

 std::mutex root_lock_;



 // This mutex sequences all writes operations and allows only one write operation at a time.

 std::mutex write_lock_;



 // Stores the current root for the trie.

 Trie root_;

};

//trie.cpp

\#include "trie.h"

\#include <string_view>



template <class T>

auto Trie::Get(std::string_view key) const -> const T * {

 // You should walk through the trie to find the node corresponding to the key. If the node doesn't exist, return

 // nullptr. After you find the node, you should use `dynamic_cast` to cast it to `const TrieNodeWithValue<T> *`. If

 // dynamic_cast returns `nullptr`, it means the type of the value is mismatched, and you should return nullptr.

 // Otherwise, return the value.

 throw "Trie::Get is not implemented.";

}



template <class T>

auto Trie::Put(std::string_view key, T value) const -> Trie {

 // Note that `T` might be a non-copyable type. Always use `std::move` when creating `shared_ptr` on that value.

 // You should walk through the trie and create new nodes if necessary. If the node corresponding to the key already

 // exists, you should create a new `TrieNodeWithValue`.

 throw "Trie::Put is not implemented.";

}



auto Trie::Remove(std::string_view key) const -> Trie {

 // You should walk through the trie and remove nodes if necessary. If the node doesn't contain a value any more,

 // you should convert it to `TrieNode`. If a node doesn't have children any more, you should remove it.

 throw "Trie::Remove is not implemented.";

}



// Below are explicit instantiation of template functions.

//

// Generally people would write the implementation of template classes and functions in the header file. However, we

// separate the implementation into a .cpp file to make things clearer. In order to make the compiler know the

// implementation of the template functions, we need to explicitly instantiate them here, so that they can be picked up

// by the linker.



template auto Trie::Put(std::string_view key, uint32_t value) const -> Trie;

template auto Trie::Get(std::string_view key) const -> const uint32_t *;



template auto Trie::Put(std::string_view key, uint64_t value) const -> Trie;

template auto Trie::Get(std::string_view key) const -> const uint64_t *;



template auto Trie::Put(std::string_view key, std::string value) const -> Trie;

template auto Trie::Get(std::string_view key) const -> const std::string *;



// If your solution cannot compile for non-copy tests, you can remove the below lines to get partial score.



using Integer = std::unique_ptr<uint32_t>;



template auto Trie::Put(std::string_view key, Integer value) const -> Trie;

template auto Trie::Get(std::string_view key) const -> const Integer *;



template auto Trie::Put(std::string_view key, MoveBlocked value) const -> Trie;

template auto Trie::Get(std::string_view key) const -> const MoveBlocked *;

//trie_store.cpp

\#include "trie_store.h"



template <class T>

auto TrieStore::Get(std::string_view key) -> std::optional<ValueGuard<T>> {

 // Pseudo-code:

 // (1) Take the root lock, get the root, and release the root lock. Don't lookup the value in the

 //   trie while holding the root lock.

 // (2) Lookup the value in the trie.

 // (3) If the value is found, return a ValueGuard object that holds a reference to the value and the

 //   root. Otherwise, return std::nullopt.

 throw "TrieStore::Get is not implemented.";

}



template <class T>

void TrieStore::Put(std::string_view key, T value) {

 // You will need to ensure there is only one writer at a time. Think of how you can achieve this.

 // The logic should be somehow similar to `TrieStore::Get`.

 throw "TrieStore::Put is not implemented.";

}



void TrieStore::Remove(std::string_view key) {

 // You will need to ensure there is only one writer at a time. Think of how you can achieve this.

 // The logic should be somehow similar to `TrieStore::Get`.

 throw "TrieStore::Remove is not implemented.";

}



// Below are explicit instantiation of template functions.



template auto TrieStore::Get(std::string_view key) -> std::optional<ValueGuard<uint32_t>>;

template void TrieStore::Put(std::string_view key, uint32_t value);



template auto TrieStore::Get(std::string_view key) -> std::optional<ValueGuard<std::string>>;

template void TrieStore::Put(std::string_view key, std::string value);



// If your solution cannot compile for non-copy tests, you can remove the below lines to get partial score.



using Integer = std::unique_ptr<uint32_t>;



template auto TrieStore::Get(std::string_view key) -> std::optional<ValueGuard<Integer>>;

template void TrieStore::Put(std::string_view key, Integer value);



template auto TrieStore::Get(std::string_view key) -> std::optional<ValueGuard<MoveBlocked>>;

template void TrieStore::Put(std::string_view key, MoveBlocked value);

//SimpleGTest.h

\#ifndef SIMPLE_GTEST_H

\#define SIMPLE_GTEST_H



\#include <cassert>

\#include <iostream>

\#include <string>

\#include <fmt/core.h>

\#include <fmt/format.h>



// å®šä¹‰è¾…åŠ©å®ç”¨äºè¾“å‡ºå¤±è´¥ä¿¡æ¯

\#define REPORT_FAILURE(msg) \

  std::cerr << "Test failed at " << __FILE__ << ":" << __LINE__ << " - " << msg << std::endl;



// å®šä¹‰é€šç”¨æ–­è¨€æ¨¡æ¿

\#define EXPECT_TRUE(condition) \

  if (!(condition)) { \

â€‹    REPORT_FAILURE("EXPECT_TRUE failed: " #condition); \

  }



\#define ASSERT_TRUE(condition) \

  if (!(condition)) { \

â€‹    REPORT_FAILURE("ASSERT_TRUE failed: " #condition); \

â€‹    assert(condition); \

  }



\#define EXPECT_FALSE(condition) \

  if (condition) { \

â€‹    REPORT_FAILURE("EXPECT_FALSE failed: " #condition); \

  }



\#define ASSERT_FALSE(condition) \

  if (condition) { \

â€‹    REPORT_FAILURE("ASSERT_FALSE failed: " #condition); \

â€‹    assert(!(condition)); \

  }



// ç›¸ç­‰æ–­è¨€

\#define EXPECT_EQ(val1, val2) \

  if (!((val1) == (val2))) { \

â€‹    REPORT_FAILURE("EXPECT_EQ failed: " #val1 " == " #val2 << ", actual values: " << (val1) << " != " << (val2)); \

  }



\#define ASSERT_EQ(val1, val2) \

  if (!((val1) == (val2))) { \

â€‹    REPORT_FAILURE("ASSERT_EQ failed: " #val1 " == " #val2 << ", actual values: " << (val1) << " != " << (val2)); \

â€‹    assert((val1) == (val2)); \

  }



\#define ASSERT_EQ_NO_REPORT(val1, val2) \

  if (!((val1) == (val2))) { \

â€‹    assert((val1) == (val2)); \

  }



// ä¸ç›¸ç­‰æ–­è¨€

\#define EXPECT_NE(val1, val2) \

  if ((val1) == (val2)) { \

â€‹    REPORT_FAILURE("EXPECT_NE failed: " #val1 " != " #val2 << ", actual values: " << (val1) << " == " << (val2)); \

  }



\#define ASSERT_NE(val1, val2) \

  if ((val1) == (val2)) { \

â€‹    REPORT_FAILURE("ASSERT_NE failed: " #val1 " != " #val2 << ", actual values: " << (val1) << " == " << (val2)); \

â€‹    assert((val1) != (val2)); \

  }



\#define ASSERT_NE_NO_REPORT(val1, val2) \

  if ((val1) == (val2)) { \

â€‹    assert((val1) != (val2)); \

  }

  

// è¾ƒå°æ–­è¨€

\#define EXPECT_LT(val1, val2) \

  if (!((val1) < (val2))) { \

â€‹    REPORT_FAILURE("EXPECT_LT failed: " #val1 " < " #val2 << ", actual values: " << (val1) << " >= " << (val2)); \

  }



\#define ASSERT_LT(val1, val2) \

  if (!((val1) < (val2))) { \

â€‹    REPORT_FAILURE("ASSERT_LT failed: " #val1 " < " #val2 << ", actual values: " << (val1) << " >= " << (val2)); \

â€‹    assert((val1) < (val2)); \

  }



// è¾ƒå¤§æ–­è¨€

\#define EXPECT_GT(val1, val2) \

  if (!((val1) > (val2))) { \

â€‹    REPORT_FAILURE("EXPECT_GT failed: " #val1 " > " #val2 << ", actual values: " << (val1) << " <= " << (val2)); \

  }



\#define ASSERT_GT(val1, val2) \

  if (!((val1) > (val2))) { \

â€‹    REPORT_FAILURE("ASSERT_GT failed: " #val1 " > " #val2 << ", actual values: " << (val1) << " <= " << (val2)); \

â€‹    assert((val1) > (val2)); \

  }



\#define TEST(TestSuite, TestName) \

  void TestSuite##_##TestName()



\#endif // SIMPLE_GTEST_H